// ============================================
// CONFIGURATION
// ============================================

const DB_CONFIG = {
  // JDBC connection string format:
  // jdbc:postgresql://HOST:PORT/DATABASE_NAME
  jdbcUrl: 'jdbc:postgresql://YOUR_HOST:5432/YOUR_DATABASE',
  username: 'YOUR_USERNAME',
  password: 'YOUR_PASSWORD'
};

// Column mapping - maps sheet columns to database columns
// If your sheet columns match exactly, this will be auto-detected
// You can customize this if your sheet has different column names
const COLUMN_MAPPING = {
  // Sheet Column Name: Database Column Name
  // Example custom mapping:
  // 'Job Title': 'job_title',
  // 'Company': 'company_name',
  // Leave empty for auto-detection
};

// Columns that should NOT be synced (auto-generated by database)
const SKIP_COLUMNS = ['id', 'created_at', 'updated_at'];

// ============================================
// MENU CREATION
// ============================================

/**
 * Creates custom menu when spreadsheet opens
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('PostgreSQL Sync')
    .addItem('Sync Jobs to Database', 'syncJobsToDatabase')
    .addItem('Test Connection', 'testDatabaseConnection')
    .addItem('Clear All Jobs (Danger)', 'clearAllJobs')
    .addToUi();
}

// ============================================
// MAIN SYNC FUNCTION
// ============================================

/**
 * Main function to sync Google Sheets data to PostgreSQL
 */
function syncJobsToDatabase() {
  const ui = SpreadsheetApp.getUi();
  
  try {
    // Get active sheet data
    const sheet = SpreadsheetApp.getActiveSheet();
    const data = sheet.getDataRange().getValues();
    
    if (data.length < 2) {
      ui.alert('Error', 'Sheet must have at least a header row and one data row.', ui.ButtonSet.OK);
      return;
    }
    
    // First row contains headers
    const headers = data[0].map(h => String(h).trim());
    const rows = data.slice(1);
    
    // Validate headers
    if (!validateHeaders(headers)) {
      ui.alert('Error', 'Missing required columns. At minimum, you need: job_title, location, job_description, requirements', ui.ButtonSet.OK);
      return;
    }
    
    // Connect to database
    const conn = connectToDatabase();
    
    if (!conn) {
      ui.alert('Error', 'Failed to connect to database. Check your credentials.', ui.ButtonSet.OK);
      return;
    }
    
    // Start transaction
    conn.setAutoCommit(false);
    
    let successCount = 0;
    let errorCount = 0;
    const errors = [];
    
    // Process each row
    for (let i = 0; i < rows.length; i++) {
      const rowNum = i + 2; // +2 because of header row and 0-based index
      const row = rows[i];
      
      try {
        // Skip empty rows
        if (isEmptyRow(row)) {
          continue;
        }
        
        // Convert row to job object
        const jobData = rowToJobObject(headers, row);
        
        // Validate required fields
        if (!jobData.job_title || !jobData.location || !jobData.job_description || !jobData.requirements) {
          errors.push(`Row ${rowNum}: Missing required fields`);
          errorCount++;
          continue;
        }
        
        // Upsert job to database
        upsertJob(conn, jobData);
        successCount++;
        
      } catch (error) {
        errorCount++;
        errors.push(`Row ${rowNum}: ${error.message}`);
      }
    }
    
    // Commit transaction
    conn.commit();
    conn.close();
    
    // Show results
    let message = `Sync completed!\n\nSuccessful: ${successCount}\nErrors: ${errorCount}`;
    
    if (errors.length > 0) {
      message += '\n\nErrors:\n' + errors.slice(0, 10).join('\n');
      if (errors.length > 10) {
        message += `\n... and ${errors.length - 10} more errors`;
      }
    }
    
    ui.alert('Sync Complete', message, ui.ButtonSet.OK);
    
  } catch (error) {
    ui.alert('Error', `Sync failed: ${error.message}`, ui.ButtonSet.OK);
    Logger.log('Sync error: ' + error.stack);
  }
}

// ============================================
// DATABASE FUNCTIONS
// ============================================

/**
 * Establishes connection to PostgreSQL database
 */
function connectToDatabase() {
  try {
    const conn = Jdbc.getConnection(
      DB_CONFIG.jdbcUrl,
      DB_CONFIG.username,
      DB_CONFIG.password
    );
    return conn;
  } catch (error) {
    Logger.log('Database connection error: ' + error.message);
    return null;
  }
}

/**
 * Tests database connection
 */
function testDatabaseConnection() {
  const ui = SpreadsheetApp.getUi();
  const conn = connectToDatabase();
  
  if (conn) {
    try {
      const stmt = conn.createStatement();
      const rs = stmt.executeQuery('SELECT COUNT(*) as count FROM jobs');
      rs.next();
      const count = rs.getInt('count');
      conn.close();
      ui.alert('Success', `Connected successfully!\nCurrent jobs in database: ${count}`, ui.ButtonSet.OK);
    } catch (error) {
      conn.close();
      ui.alert('Error', `Connected but query failed: ${error.message}`, ui.ButtonSet.OK);
    }
  } else {
    ui.alert('Error', 'Failed to connect to database. Check your credentials in the script.', ui.ButtonSet.OK);
  }
}

/**
 * Upserts a job record to the database
 * Uses job_title + company_name + location as unique identifier
 */
function upsertJob(conn, jobData) {
  // Build the UPSERT query using PostgreSQL's INSERT ON CONFLICT
  const columns = Object.keys(jobData).filter(col => !SKIP_COLUMNS.includes(col));
  const placeholders = columns.map((_, i) => `?`).join(', ');
  const updateSet = columns
    .filter(col => col !== 'job_title' && col !== 'company_name' && col !== 'location')
    .map(col => `${col} = EXCLUDED.${col}`)
    .join(', ');
  
  const sql = `
    INSERT INTO jobs (${columns.join(', ')})
    VALUES (${placeholders})
    ON CONFLICT (job_title, company_name, location) 
    DO UPDATE SET ${updateSet}
  `;
  
  const stmt = conn.prepareStatement(sql);
  
  // Set parameters
  columns.forEach((col, index) => {
    const value = jobData[col];
    const paramIndex = index + 1;
    
    if (value === null || value === undefined || value === '') {
      stmt.setNull(paramIndex, Jdbc.Types.VARCHAR);
    } else if (col === 'skills_required') {
      // Convert array to PostgreSQL array format
      const array = conn.createArrayOf('VARCHAR', value);
      stmt.setArray(paramIndex, array);
    } else if (typeof value === 'number') {
      stmt.setInt(paramIndex, value);
    } else {
      stmt.setString(paramIndex, String(value));
    }
  });
  
  stmt.executeUpdate();
  stmt.close();
}

// ============================================
// HELPER FUNCTIONS
// ============================================

/**
 * Validates that required headers are present
 */
function validateHeaders(headers) {
  const required = ['job_title', 'location', 'job_description', 'requirements'];
  const normalizedHeaders = headers.map(h => normalizeColumnName(h));
  
  for (const req of required) {
    if (!normalizedHeaders.includes(req)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Converts sheet row to job object
 */
function rowToJobObject(headers, row) {
  const jobData = {};
  
  headers.forEach((header, index) => {
    const normalizedHeader = normalizeColumnName(header);
    
    // Skip auto-generated columns
    if (SKIP_COLUMNS.includes(normalizedHeader)) {
      return;
    }
    
    let value = row[index];
    
    // Handle special columns
    if (normalizedHeader === 'skills_required') {
      // Convert comma-separated string to array
      if (value && typeof value === 'string') {
        value = value.split(',').map(s => s.trim()).filter(s => s !== '');
      } else if (!Array.isArray(value)) {
        value = [];
      }
    } else if (['minimum_age', 'maximum_age', 'minimum_experience_months', 'openings_count'].includes(normalizedHeader)) {
      // Convert to integer
      value = value ? parseInt(value) : null;
    } else if (value === '' || value === null || value === undefined) {
      value = null;
    } else {
      value = String(value).trim();
    }
    
    jobData[normalizedHeader] = value;
  });
  
  // Set defaults for optional fields if not provided
  if (!jobData.hasOwnProperty('gender_preference')) {
    jobData.gender_preference = 'any';
  }
  if (!jobData.hasOwnProperty('job_type')) {
    jobData.job_type = 'full-time';
  }
  if (!jobData.hasOwnProperty('employment_status')) {
    jobData.employment_status = 'permanent';
  }
  if (!jobData.hasOwnProperty('status')) {
    jobData.status = 'active';
  }
  if (!jobData.hasOwnProperty('openings_count')) {
    jobData.openings_count = 1;
  }
  if (!jobData.hasOwnProperty('minimum_experience_months')) {
    jobData.minimum_experience_months = 0;
  }
  
  return jobData;
}

/**
 * Normalizes column name to match database schema
 */
function normalizeColumnName(columnName) {
  // Check if there's a custom mapping
  if (COLUMN_MAPPING[columnName]) {
    return COLUMN_MAPPING[columnName];
  }
  
  // Convert to lowercase and replace spaces with underscores
  return columnName.toLowerCase().replace(/\s+/g, '_');
}

/**
 * Checks if a row is empty
 */
function isEmptyRow(row) {
  return row.every(cell => cell === '' || cell === null || cell === undefined);
}

/**
 * Clears all jobs from database (DANGER - use with caution)
 */
function clearAllJobs() {
  const ui = SpreadsheetApp.getUi();
  
  const response = ui.alert(
    'WARNING',
    'This will DELETE ALL jobs from the database. This action cannot be undone. Are you sure?',
    ui.ButtonSet.YES_NO
  );
  
  if (response !== ui.Button.YES) {
    return;
  }
  
  try {
    const conn = connectToDatabase();
    if (!conn) {
      ui.alert('Error', 'Failed to connect to database.', ui.ButtonSet.OK);
      return;
    }
    
    const stmt = conn.createStatement();
    stmt.executeUpdate('DELETE FROM jobs');
    conn.close();
    
    ui.alert('Success', 'All jobs have been deleted from the database.', ui.ButtonSet.OK);
  } catch (error) {
    ui.alert('Error', `Failed to clear jobs: ${error.message}`, ui.ButtonSet.OK);
  }
}

